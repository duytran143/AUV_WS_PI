#!/usr/bin/env python3
"""
velocity_estimator_node.py — ROS 2 node for estimating body-frame velocity from IMU

* Subscribe to accelerometer (/accel: Vector3Stamped) and gyro (/gyro: Vector3Stamped)
* Perform gravity compensation, bias tracking, LPF, leaky-integrator + adaptive leak + ZUPT
* Publish estimated velocity (Vector3Stamped) on /vel_est topic at CONTROL_HZ
"""
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Vector3Stamped
import numpy as np

class VelocityEstimatorNode(Node):
    def __init__(self):
        # Node name set to 'velocity_estimator_node'
        super().__init__('velocity_estimator_node')
        self.CONTROL_HZ = 100.0
        self.ZUPT_DELAY = 0.1             # s
        self.STATIONARY_ACC_THRESH = 0.15 # m/s²
        self.LPF_ALPHA = 0.8              # cutoff ~8 Hz
        self.LEAK_NORMAL = 0.1            # normal leak rate
        self.LEAK_IDLE = 10.0             # idle leak rate (fast decay)

        self.v_est = np.zeros(3)
        self.a_f_prev = np.zeros(3)
        self.a_f = np.zeros(3)
        self.bias = np.zeros(3)
        self.stationary_start = None
        self.last_time = self.get_clock().now()
        self.yaw_rate = 0.0

        # Subscribers
        self.acc_sub = self.create_subscription(
            Vector3Stamped, '/accel', self.accel_cb, 10)
        self.gyro_sub = self.create_subscription(
            Vector3Stamped, '/gyro', self.gyro_cb, 10)
        # Publisher
        self.vel_pub = self.create_publisher(
            Vector3Stamped, '/vel_est', 10)
        # Timer for control loop
        self.timer = self.create_timer(1.0/self.CONTROL_HZ, self.publish_vel)
        self.get_logger().info('velocity_estimator_node ready.')

    def accel_cb(self, msg: Vector3Stamped):
        a_raw = np.array([msg.vector.x, msg.vector.y, msg.vector.z])
        a_lin = a_raw - np.array([0, 0, 9.81])  # gravity compensation
        norm = np.linalg.norm(a_lin)
        # Bias update
        if norm < self.STATIONARY_ACC_THRESH:
            if self.stationary_start is None:
                self.stationary_start = self.get_clock().now()
            self.bias = 0.995*self.bias + 0.005*a_lin
        else:
            self.stationary_start = None
        # Low-pass filter
        self.a_f = self.LPF_ALPHA*(a_lin - self.bias) + (1-self.LPF_ALPHA)*self.a_f_prev
        self.a_f_prev = self.a_f
        # Time update
        now = self.get_clock().now()
        dt = (now - self.last_time).nanoseconds * 1e-9
        lam = self.LEAK_IDLE if norm < self.STATIONARY_ACC_THRESH else self.LEAK_NORMAL
        self.v_est = (1 - lam*dt) * self.v_est
        if norm >= self.STATIONARY_ACC_THRESH:
            self.v_est += self.a_f * dt
        self.last_time = now

    def gyro_cb(self, msg: Vector3Stamped):
        self.yaw_rate = msg.vector.z

    def publish_vel(self):
        vel_msg = Vector3Stamped()
        vel_msg.header.stamp = self.get_clock().now().to_msg()
        vel_msg.vector.x, vel_msg.vector.y, vel_msg.vector.z = self.v_est
        self.vel_pub.publish(vel_msg)
        # Log filtered accel, estimated velocity, yaw-rate
        log = (
            f"accel_filt=[{self.a_f[0]:+6.2f},{self.a_f[1]:+6.2f}] "
            f"vel_est=[{self.v_est[0]:+6.2f},{self.v_est[1]:+6.2f}] "
            f"yaw_rate={self.yaw_rate:+6.2f}"
        )
        print(log, end='\r', flush=True)


def main(args=None):
    rclpy.init(args=args)
    node = VelocityEstimatorNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
